Through this assignment, I learned how different Git integration strategies affect both collaboration and project history. Using merge, rebase, squash, and cherry-pick showed clear differences in how commits appear and how conflicts are handled. A standard merge preserved the full history of feature1 and introduced a merge commit, making it clear when the feature was integrated. Rebasing feature2 rewrote the commit history into a linear sequence, which made the history cleaner but required more care since it modifies existing commits. Squashing feature3 condensed multiple development commits into a single commit, resulting in a simpler and more readable history. Cherry-picking demonstrated how individual commits can be selectively applied without bringing in an entire branch. From this, I learned that merges are best for shared branches where history matters, rebasing is useful for cleaning up local work before integration, squashing is ideal for final feature integration, and cherry-picking is helpful for applying specific fixes. Overall, this assignment helped me understand when and why each Git strategy should be used in real-world projects.
